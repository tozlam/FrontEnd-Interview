### instanceof的作用及原理/实现？
- instanceof 用来判断一个对象构造函数的prototype是否存在于另一个对象的原型链上

- 实现：

````
    function myInstanceof (left, right) {
        let proto = Object.getPrototypeOf(left);
        let prototype = right.prototype;
        
        while(1) {
            if (proto === prototype) {
                return true;
            }
            
            proto = Object.getPrototypeOf(proto);
            
            if (!proto) {
                return false;
            }
        }
    }
````

- 原理： 
 拿到对象1的构造函数prototype和对象2的原型进行匹配，如果匹配不到则向对象2的原型链进行匹配，
 直到原型链到达Object.getPrototypeOf === null 的时候，返回false；
 
 ### new 操作符具体干了什么呢？如何实现？
 - 创建一个空对象
 - 设置原型，将对象的原型设置为构造函数的prototype
 - 将this指向新对象并执行构造函数
 - 判断构造函数返回的值的类型 如果是引用类型则直接返回这个引用类型 如果是值则返回新对象
 
 ````
 function myNew() {
    let obj = new Object();// 创建一个空的对象
    let constructor = [].call(arguments);// 获得构造函数
    object._proto_ = constructor.prototype;// 链接到原型
    let result = constructor.apply(obj, arguments);// 绑定 this，执行构造函数
    return typeof result === 'object' ? result : obj; // 确保 new 出来的是个对象
 }
 
 ````

### 闭包
````
闭包就是函数运行时候的一种机制。我们函数中的代码执行的时候是在内存中执行的，内存中有栈内存和堆内存；栈内存用来创建上下文，让代码进来执行，形成环境区分...堆内存用来存对象类型的...
函数进栈执行，一般情况下执行完会被出栈释放，但是有些情况不会被出栈释放，比方说他某些东西被上下文以外的东西占用了就不会出栈释放，这也是由于浏览器的垃圾回收机制所导致的。
这样不被释放的话我们之前存的那些变量也就不会被释放了，这样也就产生了一个闭包的机制，这样那些存下来的变量的值也可以供其下级上下文通过作用域链调取使用。
因为他不被释放，所以栈内存空间会越来越大，这样对代码运行性能会有影响，所以我认为闭包不能被滥用。
````

### 垃圾回收机制
````
JavaScript代码运行时，需要分配内存空间来储存变量和值。当变量不在参与运行时，就需要系统收回被占用的内存空间，这就是垃圾回收。

● Javascript 具有自动垃圾回收机制，会定期对那些不再使用的变量、对象所占用的内存进行释放，原理就是找到不再使用的变量，然后释放掉其占用的内存。
● JavaScript中存在两种变量：局部变量和全局变量。
全局变量的生命周期会持续要页面卸载；
而局部变量声明在函数中，它的生命周期从函数执行开始，直到函数执行结束，在这个过程中，局部变量会在堆或栈中存储它们的值，当函数执行结束后，这些局部变量不再被使用，它们所占有的空间就会被释放。
● 不过，当局部变量被外部函数使用时，其中一种情况就是闭包，在函数执行结束后，函数外部的变量依然指向函数内部的局部变量，此时局部变量依然在被使用，所以不会回收。

浏览器通常使用的垃圾回收方法有两种：标记清除，引用计数。

虽然浏览器可以进行垃圾自动回收，但是当代码比较复杂时，垃圾回收所带来的代价比较大，所以应该尽量减少垃圾回收。
● 对数组进行优化：在清空一个数组时，最简单的方法就是给其赋值为[ ]，但是与此同时会创建一个新的空对象，可以将数组的长度设置为0，以此来达到清空数组的目的。
● 对object进行优化：对象尽量复用，对于不再使用的对象，就将其设置为null，尽快被回收。
● 对函数进行优化：在循环中的函数表达式，如果可以复用，尽量放在函数的外面。
````
 
### 前端页面性能指标
````
首先前端性能指标一般分为以下几种：

首屏绘制（First Paint，FP） 是时间线上的第一个“时间点”，是指浏览器从响应用户输入网址地址，到浏览器开始显示内容的时间，简而言之就是浏览器第一次发生变化的时间。
  + 一种比较简单的做法是在 body 标签之前获取当前时间 - performance.timing.navigationStart,
  或者直接获取 performance 中关于 paint 的两个数据，都可以直接作为白屏数据，这两个数据一般差别不大。
首屏内容绘制（First Contentful Paint，FCP） 是指浏览器从响应用户输入网络地址，在页面首次绘制文本，图片（包括背景图）、非白色的 canvas 或者SVG 才算做 FCP
  + performance.timing.loadEventEnd - performance.timing.navigationStart
可交互时间（Time to Interactive，TTI） 表示网页第一次完全达到可交互状态的时间点。可交互状态指的是页面上的 UI 组件是可以交互的（可以响应按钮的点击或在文本框输入文字等），不仅如此，此时主线程已经达到“流畅”的程度，主线程的任务均不超过50毫秒。在一般的管理系统中，TTI 是一个很重要的指标。
  + domContentLoadedEventEnd - navigationStart
最大内容绘制（Largest Contentful Paint，LCP)  表示页面的“主要内容”开始出现在屏幕上的时间点，它以前是我们测量用户加载体验的主要指标。本质上是通过一个算法来猜测某个时间点可能是 FMP，但是最好的情况也只有77%的准确率，在lighthouse6.0 的时候废弃掉了这个指标，取而代之的是 LCP 这个指标。
首次有效绘制（First Meaning Paint, FMP） 表示可视区“内容”最大的可见元素开始出现在屏幕上的时间点。

````

### ESM和CommonJS的区别
````
CommonJS 模块输出的是一个值的拷贝，ESM输出的是值的引用。
  + CommonJS一旦输出一个值，模块内部的变化就影响不到这个值
  + ESM是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块
CommonJS 模块是运行时加载，ESM是编译时加载，效率要比 CommonJS 模块的加载方式高。
ES6 Module可以导出多个值，而CommonJs 是单个值导出
CommonJS 模块的require()是同步加载模块，ESM的import命令是异步加载，有一个独立的模块依赖的解析阶段。

+ Commonjs模块加载ESM模块
CommonJS 的require()命令不能加载 ES6 模块，会报错，只能使用import()这个方法加载。
require()不支持 ES6 模块的一个原因是，它是同步加载，而 ES6 模块内部可以使用顶层await命令，导致无法被同步加载。

+ ESM模块加载Commonjs模块
只能整体加载，不能只加载单一的输出项
// 正确
import packageMain from 'commonjs-package';
// 报错
import { method } from 'commonjs-package';
因为 ES6 模块需要支持静态代码分析，而 CommonJS 模块的输出接口是module.exports，是一个对象，无法被静态分析，所以只能整体加载


````

### Object.create(null)和直接创建一个{}有什么区别？
````
1、Object.create() 必须接收一个对象参数，创建的新对象的原型指向接收的参数对象
  而通过Object.create(null)创建的对象是一个干净的对象，也就是没有原型，不继承Object原型链上的属性
2、new Object()创建的对象是 Object的实例，原型永远指向Object.prototype，{}创建的对象与其一样都会继承Object对象的所有属性

Object.create(null)的应用场景
可以创建一个干净且高度可定制的对象当做数据字典，进行循环取用，可以提高循环效率。
这个时候如果对象有原型链，那便会在循环的时候去循环它的各个属性和方法，效率则会降低
````

### 介绍JavaScript的原型，原型链，有什么特点？
````
原型：
JavaScript的所有对象中都包含了一个 [proto] 内部属性，这个属性所对应的就是该对象的原型
JavaScript的函数对象，除了原型 [proto] 之外，还预置了 prototype 属性
当函数对象作为构造函数创建实例时，该 prototype 属性值将被作为实例对象的原型 [proto]。

原型链：
当一个对象调用的属性/方法自身不存在时，就会去自己 [proto] 关联的前辈 prototype 对象上去找
如果没找到，就会去该 prototype 原型 [proto] 关联的前辈 prototype 去找。依次类推，直到找到属性/方法或 undefined 为止。从而形成了所谓的“原型链”

原型特点：
JavaScript对象是通过引用来传递的，当修改原型时，与之相关的对象也会继承这一改变
````


### 在一个DOM上同时绑定两个点击事件：一个用捕获，一个用冒泡。事件会执行几次，先执行冒泡还是捕获
````
该DOM上的事件如果被触发，会执行两次（执行次数等于绑定次数）
如果该DOM是目标元素，则按事件绑定顺序执行，不区分冒泡/捕获
如果该DOM是处于事件流中的非目标元素，则先执行捕获，后执行冒泡
````

### 谈谈this对象的理解
````
this 总是指向函数的直接调用者
如果有 new 关键字，this 指向 new 出来的实例对象
在事件中，this指向触发这个事件的对象
IE下 attachEvent 中的this总是指向全局对象Window
````

### 什么是 Window 对象，什么是 Document 对象
  ````
  Window 对象表示当前浏览器的窗口，是JavaScript的顶级对象。
  我们创建的所有对象、函数、变量都是 Window 对象的成员。
  Window 对象的方法和属性是在全局范围内有效的。
  Document 对象是 HTML 文档的根节点与所有其他节点（元素节点，文本节点，属性节点, 注释节点）
  Document 对象使我们可以通过脚本对 HTML 页面中的所有元素进行访问
  Document 对象是 Window 对象的一部分，可通过 window.document 属性对其进行访问
  ````

### 作用域和作用域链
````
作用域就是变量和函数的可访问范围；作用域分为全局作用域、函数作用域和块级作用域。
在当前作用域查找变量，如果查找不到就会向父级作用域去查找，依次向上查找，直到全局作用域，这一层一层的关系就是作用域链
````

### css、js的加载是否阻塞DOM的解析与渲染?
````
览器内核（渲染进程）拿到静态资源后，渲染大概可以划分成以下几个步骤：

解析html构建dom树
解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树）
布局render树（Layout/reflow），负责各元素尺寸、位置的计算
绘制render树（paint），绘制页面像素信息
浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。
从以上步骤可以得出几个结论：
1.html和css的加载和解析是异步的，不会互相干扰
2.只有等dom树和cssom树构建完成并且合并成render树之后，页面才开始渲染，所以css的加载不会影响dom的解析，但会影响dom的渲染

JS 会阻塞 DOM 解析:
当解析器遇到script标签时（不带有async/defer属性），浏览器会停止DOM的解析，会一直等到该script的加载并执行后，才继续往下解析。
比较合理的解释就是，首先浏览器无法知晓JS的具体内容，倘若先解析DOM，万一JS内部全部删除掉DOM，那么浏览器就白忙活了，所以就干脆暂停解析DOM，等到JS执行完成再继续解析。

CSS 会阻塞 JS 的执行:
我们从head开始解析，首先遇到link标签，去加载css（加载需要3s），此时浏览器不会停下来，会继续往下解析，然后遇到script标签，开始加载js，js很快就加载完了，
但是js不会马上执行，因为它会等到上面的css资源加载完成之后再开始执行。从而导致了下面的p标签一直没有得到解析，因为上面说了js是会阻塞DOM的解析的，浏览器会等到js执行了才会继续往下解析DOM。

千万不要认为是css的加载阻塞了DOM的解析！
流程是：css和js可以同时去加载—>css加载很慢，即使js已经加载完了也会等到css加载完了才开始执行—>js一直不执行所以阻塞了DOM的解析
可以这样理解，浏览器并不知道js中的代码会干些什么，js可以去改动DOM，也可以获取/改变css样式。js要获取正确的样式就必须等css加载完
````

### 浏览器的event Loop
````
因为js是单线程的，但是浏览器的事件任务又分成了同步任务和异步任务，所以需要一种能告诉浏览器任务执行顺序，解决js单线程执行任务不会阻塞的一种机制，就是事件循环机制。
我们的同步任务是在主线程执行的，形成一个执行栈。
还有一个任务队列，当异步代码执行完毕后，会将任务的回调事件放入到任务队列中。
异步任务分成宏任务和微任务，宏任务包括setTimeout、setImmediate、setInterval这些，微任务包括像promise、nextTick这些。
执行顺序就是先执行同步任务代码，遇到微任务的放到微任务队列中，遇到宏任务放到宏任务队列中；
所有同步任务执行完毕后，将微任务队列中的所有任务放到执行栈当中执行；
微任务都执行完毕后，再取出（一个）宏任务到执行栈中执行。。。如此反复，形成一个循环
````


