### CRP: 关键渲染路径
+ 围绕渲染的机制和步骤，去详细的进行每一步的优化，以此来提高页面的渲染速度和运行性能
+ 从服务器基于HTTP网络请求回来的数据
    + 16进制的文件流
    + 浏览器把他解析为字符串（HTML字符串）
    + 按照W3C规则识别成一个个节点（词法解析）
    + 生成xx树
+ 访问页面，请求回来的是一个HTML文档，浏览器开始自上而下渲染
    + 进程： 一般指一个程序（浏览器打开一个页面就相当于开了一个进程）
    + 线程： 进程中具体去执行事务的东西，一个线程只能干一件事
    + 一个进程可能包含多个线程

+ 同步编程：一般是只有一个线程去处理事情，上面的事情处理不完，下面的事情无法处理
+ 异步编程：
    + 多线程异步编程
    + 单线程异步编程(JS是EventQueue+EventLoop机制完成单线程异步编程)
    
+ 浏览器是可以开辟多个进程/线程的
    + GUI渲染线程：渲染页面
    + JS引擎线程： 渲染解析JS代码
    + HTTP网络线程：可以开辟n多个，从服务器获取资源和数据的
    + 定时器监听线程 
    + 事件监听线程 
  
+ JS是单线程的：因为浏览器只分配一个线程去渲染解析JS代码
  + 渲染JS代码的时候，上一个任务没有处理完，下一个任务是无法执行的，只能同时做一件事（同步编程）
  + JS代码中也有异步编程（单线程异步编程）：
    + EventQueue 事件队列：等待执行的任务
    + WebApi 监听区域：监听哪些任务可以去执行
    + EventLoop 事件循环机制
  + JS异步编程的操作：
    + 宏任务
      + setTimeout/setInterval定时器
      + 事件绑定/队列
      + XMLHttpRequest/Fetch
      + setImmediate(Node里的)
    + 微任务
      + Promise
      + async/await
      + queueMicroTask 
      + MutationObserver 监听DOM的改变
      + IntersectionObserver 监听元素与当前视口的交叉信息（图片延迟加载可以基于这个实现）
      + process.nextTick(Node)

    
+ 渲染页面过程中
    + 遇到style内嵌样式，GUI直接渲染即可
      -> 如果css代码量少那么直接使用内嵌即可，拉去HTML的同时CSS也回来了，直接渲染即可
      -> 如果CSS代码多，如果还用内嵌，会影响HTML拉取速度，也不利于维护，此时用link比较好
    + 遇到link，浏览器开辟一个HTTP线程去请求资源文件信息，同时GUI继续向下渲染（异步）
    + 遇到@import,浏览器也是开辟一个HTTP线程去请求资源文件信息，但是此时GUI暂停了（导入样式会阻碍GUI渲染），当资源请求回来后GUIc才能继续渲染（同步）
      -> 项目中应该避免使用@import
      
+ 遇到`<script src="xxx">`会阻碍GUI的渲染
    + defer 和link是类似的机制，不会阻碍GUI的渲染,当GUI渲染完才把请求回来的JS去渲染 [按顺序加载 是可以建立依赖关系的]
    + async 请求JS资源是异步的（单独开辟HTML线程去请求），此时GUI继续渲染；但是一旦JS请求回来,会立即停止GUI的处理，接下来去渲染JS [不按顺序加载 谁先请求回来谁先加载 无法建立依赖关系]
    
+ 真实项目我们一般把link放在页面的头部（是为了在没有渲染DOM的时候就去通知HTML获取CSS,这样渲染完，CSS也差不多获取到，更有效利用时间，提高渲染速度）；
+ 我们一般把JS放在页面底部，防止其阻碍GUId的渲染，如果不放在底部我们最好设置上async/defer

+ DOM TREE(DOMContentLoaded事件触发)-> 执行JS -> CSSOM TREE -> RENDER TREE渲染树(浏览器按照这个树来渲染页面) -> Layout布局计算(回流/重排) -> Painting绘制(重绘)
    + 页面第一次渲染必然会引发一次回流和重绘
    + 如果我们改变了元素的位置和大小，浏览器需要重新计算元素在视口中的位置和大小信息，重新计算的过程就是回流，一旦发生了回流操作一定也会触发重绘
    + 如果只是一些普通样式的改变,位置和大小不变，只需要重绘